2.5.3 MJI解释器
---------------

&nbsp;

Shadow Widget 的可计算表达式是一段 javascript 脚本，它由一种微型解释器（即 Mini Javascript Interpreter，简称 MJI 解释器）解释执行。被执行的脚本符合 javascript 规则，但支持范围比 javascript 小得多。

#### MJI解释器

Shadow Widget 内置 MJI 解释器，它在表达式级别，而非语句级别支持 javascript 语法规则。

先介绍该解释器的词法规则：

1. MJI 不支持在脚本中内嵌注释代码
2. 支持任意类型的 javascript 数据用于脚本计算，但直接可描述的（即字面量，Literal Notation）只支持：数值（number）、字串（string）、数组（Array）、对象（object）、布尔量（boolean）。
3. 只内置一个关键字：`while`
4. 可描述的常量值有：`true, false, null, undefined, NaN`，它们含义与 javasript 相同。

MJI 解释器支持大部分 javascript 的表达式，但不支持语句形态的语法，比如赋值语句，比如循环语句。所支持的表达式形态有：

1. 由二元操作符连接，如：`a + b`，`a.b` 等
2. 由三元操作连接，仅 `?` 表达式一种，如：`cond? a: b`
3. 取小标成员，如：`a[b]`
4. 函数调用，如：`aFunc(arg)`
5. 逗号表达式，如：`3 + 4, a.b`

所有操作符的优先级与 javascript 一样，其中二元操作符罗列如下：

```
    *     /     %     +     -     <<    >>   >>>
    <     <=    >     >=    in    ==    !=    ===   !==
    &     ^     |     &&    ||
```

除上面列明的规格，其它语法 MJI 解释器不支持，为方便大家理解，现扼要列举不支持的规格（不全）：
1. 不支持变量声明，不支持函数定义
2. 没有 new delete 关键字，也不支持 instanceof 判断
3. 不支持一元操作符，如 `++`、`--` 等不支持
4. 不支持语句级别的语法，如：赋值、控制语句（如 return、break、continue、if、else 等）

#### 附加规则

与语法相关，MJI 与 javascript 实现不尽一致的规则有：

1. 赋值   
MJI 不直接支持赋值语句，但可以用经封装的 `ex.setVar(sName,value)` 调用代替。比如：`ex.setVar("abc",3)` 等效于 `abc = 3`，setVar 调用的返回值是第二个参数 value 传入的值。

2. 循环   
MJI 也用 `while(cond,expr,expr2, ...)` 函数调用形式表达循环语句，函数参数变长，首参数 cond 要求是条件表达式，如果条件式计算结果为真（true），其后各个表达式才被计算，而且，只要条件判断成立，循环语式将持续运行，条件判断不成立才退出循环。

3. `typeof(aVar)` 要求参数 aVar 已存在，javascript 的 `typeof` 可以作用于尚未定义的符号。

4. 使用这几项变量 `props, duals, props, item, count, index` 时，自动转化成函数调用的形式。   
比如调用 `props.attr` 自动转化为 `props(0).attr`，`index` 转化为 `index(0)`，转化后固定带一个值为 0 的参数，0 表示在 0 层（即当前层）调用空间下查找。

#### 调用空间 callspace

调用空间是 MJI 脚本解释器动态执行所需的域名空间，读取的变量或函数，都要到调用空间下查找。

调用空间是一层压一层的栈式结构，当前层为 0 层，上一层是 -1 层，再向上是 -2 层。每一层调用空间都绑捆到某个 R 节点，凡使用了 `$for` 指令或 `$` 引用的节点，都新生成一个调用空间，捆绑到当前使用 `$for` 或 `$r` 的节点，新生成的空间成为当前 0 层。

用 `$for` 开启调用空间在前文已有举例，现再举一个用 '$' 开启调用空间的例子（见 demo28）：

```
  <div :t=Panel key='top' height='{null}'>
    <div :t=Div key='hello' $for='' dual-data='{{"name":"Wayne","lastName":"Chan"}}'>
      <div :t=P key='p' width='{0.9999}'>
        <span :t=Input key='name' $value='duals.data.name + " " + duals.data.lastName'></span>
        <span :t=Br></span>
        <span :t=Span key='txt' $html='"Hello, " + duals.data.name'></span>
      </div>
    </div>
    <div $='hello.p' dual-data='{{"name":"Hillary","lastName":"Clinton"}}'></div>
  </div>
```

每个调用空间都缺省定义如下符号：

1. `ex` 模块   
在可计算表达式中常用的 API，都挂在 ex 下，如 `ex.log, ex.tagValue, ex.time` 等。

2. `Math` 模块   
Javascript 的 Math 模块已预置，诸如 `Math.max, Math.floor, Math.random` 等函数可供调用。

3. `props, duals, props, item, count, index` 函数   
其中前 3 项支持用 0, -1, -2 等参数指定取哪一层的节点，或用 `sPath` 参数取指定节点，`sPath` 若用相对路径，自动以当前节点为参照。比如：`state("./toolbar").attr` 含义是：找到以 0 层节点为参照，路径为 `"./toolbar"` 的目标节点（targ），然后读取 `targ.state.attr` 的值。   
关于 `item, count, index` 的用法，请参考下一节 [循环指令](#2.5.4.) 。

4. `typeof` 函数

运行中，如果可计算表达式使用 `ex.setVar()` 登记一个新变量，会保存到当前调用空间（即 0 层空间）。

#### trigger 表达式使用独立的调用空间

Shadow Widget 仅在两种场合使用 “可计算表达式”，其一是可计算属性中，即以 `'$'` 前缀标识的属性，如 `'$value'`、`'$for'` 等，其二是选项构件的 `trigger` 属性中，两种场景有如下使用差异。

第一，在前一场景中，调用空间可以有多层，按栈式组织，而后一场景，如果在 `trigger` 登记的预设动作用来修改指定节点的 `duals.data` 数据，也需由 MJI 解释器解析执行，这时 MJI 使用的调用空间（即域名空间）是单独的、非栈式的。也就是说，在 `trigger` 表达式中，当前空间就是挂在本节点的那个空间，不再有向上查找的 -1、-2 等层的调用空间，使用 `duals(-1).attr` 会报错。

第二，前一场景中的可计算表达式若要生效，须至少有一个 `$for` 或 `$` 指令开启栈式空间，而后一场景无此要求，在选项构件中可随时使用 trigger 表达式。

须注意，两种场景下可计算表达式中 “当前调用空间” 的含义有差异，前一场景下，是指最近由 `$for` 或 `$` 新启的空间，而后一场景下，则指绑捆到 trigger 定义所在节点的那个独立调用空间。举例来说：

```
  <div :t=Panel key='top' height='{null}'>
    <div :t=P key='hello' width='{0.9999}' $for=''>
      <span :t=OptButton isolated='{true}' recheckable='{true}' dual-data='{0}' 
          trigger='[["//a",{$set:ex.time()}]]' key='a'>A</span>
      <span :t=Span $html='duals("a").data'></span>
    </div>
  </div>
```

trigger 中的 `"//a"` 相对路径，是以 trigger 表达式所在节点为参考基点，而 `$html` 表达式中的 `duals("a")` 则以 `$for` 所在的节点为参考基点。请细心体会这两者的差异，不要误用。

#### 动态节点

如下可计算属性用来描述动态节点：

```
    $for    $if    $elif    $else
```

所谓动态节点，是指运行中根据特定条件，动态决定它是否存在的节点，这里所提 “特定条件” 也是脚本表达式，由 MJI 解释器动态计算。

上述 4 个特殊的可计算属性，称为 “指令可计算属性”（Directive Evaluatable Property），相应的，其它可计算属性称为 “非指令可计算属性”。

指令可计算属性的字串表达式，简称为 “指令表达式”。指令表达式用来描述动态节点，在接下来两节 [循环指令](#2.5.4.) 与 [条件指令](#2.5.5.) 详细介绍。

&nbsp;
