2.7.5 函数式与指令式
---------------------

&nbsp;

#### Shadow Widget 分层结构

```
+----------------------+
|    构件关系范式框架     |        第 4 层
+----------------------+
|      可计算表达式      |        第 3 层
+----------------------+
|  W 树   |   双源驱动   |        第 2 层
+----------------------+
|         V-DOM        |        第 1 层
+----------------------+
```

如上图，Shadow Widget 的底部是 React 的虚拟 DOM 层，对该层附加两种管理：把各节点组织成 W 树，并为每个节点增加双源驱动机制，形成第 2 层。之后叠加 MJI 解释环境及可计算表达式支持，形成第 3 层，最后扩展若干内置构件用来描述四种构件关系，这是第 4 层。

我们拿现有 React 技术圈相关工具作比较，第 1 层是 React，第 2 层支持单向数据流机制，相当于 reflux，第 3 层解决指令描述的问题，相当于为 React 加顶帽子，用来支持类似 Angular 或 Vue 的描述机制，第 4 层定义多个与布局相关的构件，提供比 react-router 更丰富的功能。

#### 集函数式与指令式风格于一身

函数式与指令式是前端框架的两大流派，前者以 React 为代表，后者以 Angular 为代表，Shadow Widget 将这两种风格合为一体，集两种优势于一身。

虽然 Shadow Widget 支持用函数式风格编程，我们仍建议在界面描述与投影式声明的编码中，采用指令式风格，底层的 Widget 构件开发，则倾向于函数式实现。

纯粹函数式编程要求用 JSX 描述节点，不用转义标签，不用指令可计算属性（`$for`、`$if`、`$elif`、`$else`），其它的与常规 React 编程区别不大，详情请见 [进阶篇：函数式开发](#3.4.)。

#### 如何规划一个构件的属性？

一个属性可以定义在构件的 props，或 state，或 duals 之下，如何选择？以下建议供参考：

1. 参与数据驱动的属性要定义到 duals 下   
 - 参与数据驱动的场合主要有：捆绑了 `setter(value,oldValue)` 函数，可被侦听，
   在可计算表达式中用作驱动源等。
 - 所有 duals 属性都最终要到 state 下读写同名属性，即：duals 属性的 getter、setter
   通过存取 state 下同名属性实现读写。
 - 凡传入的 props 属性最终要表现为真实 DOM 节点属性的，如 `id`、`name`、`data-*` 等
 （参见 [定义双源属性](#2.2.2.) 中的透传属性列表），会自动注册为 duals 属性，另外，
   `dual-*` 与 `$expr` 也自动注册为 duals 属性。

2. 在构件生存周期内，固定不变的属性，应只定义在 props 下   
 - 这类属性通常用来标记构件的固定特性，像 `key, className` 等。
 - 某些透传到真实 DOM 的属性，在生存周期内也是固定不变的，如 `id, name` 等，
   虽被自动定义到 duals，我们也应只从 props 读取，无视 duals 与 state 有此变量即可。

3. 还有少量只在 state 定义的属性，它们不介入数据驱动，只为自身 render 输出服务   
这些属性宜限定在本构件内使用，外部不应读写，若想提供外部读写，最好改用 duals 实现。

#### <a name="import_rule"></a>重要设计原则

Shadow Widget 兼容函数式与指令式表达风格，除指令可计算属性这两种风格要区别处理外，其它地方应支持共存、互不干扰。为达到这个目标，我们应遵守一项设计原则：**所有控制逻辑都要集中在 `render()` 中处理**。

现在细化该原则，让它更好操作：

1. `getInitialState()` 中的代码一般只用来安装回调函数   
 - 注册双源属性   
注册也就是登记 setter 回调函数，给双源属性赋值时，最终在 `render()` 中通过调用 setter 函数实现。
 - 侦听父级节点的双源属性   
触发函数也是回调函数，此回调最终也在 `render()` 中运行。   
侦听源若非本级或父级节点，可能无法保证它的 duals 属性已就绪，所以，我们也常改在 `componentDidMount()` 中登记侦听。
 - 分析特定 props 属性值做特定处理   
但请注意，只能分析构件生存期内固定不变的属性，否则，您应改在其它地方实现此处理。
 - 调用 [`setEvent()`](#4.4.2.!set_event) 以编程方式定义事件回调函数   
比如 `$onClick` 函数，既能在投影类中定义，也允许在首次 `render()` 之前调用 `setEvent({$onClick:fn})` 进行定义。

2. `componentDidMount()` 一般只用来登记侦听及触发初始动作

3. `componentWillUnmount()` 一般只用来卸载回调函数

这 3 条所提的 “只用来” 是为了强调，如果你的代码不为上述限定目的而写，就该仔细想一想，这么编码是否合适。当然，不为上述限定目的，代码没用到当前构件任何属性，也未尝不可。

除了双源属性被赋值、侦听函数被触发，还有可计算表达式重新被计算，都是在 `render()` 中处理，符合上面原则。

&nbsp;
