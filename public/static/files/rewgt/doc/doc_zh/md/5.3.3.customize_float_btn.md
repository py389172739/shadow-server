5.3.3 定制浮动工具条
----------------

&nbsp;

#### 标识扩展工具集

Shadow Widget 的可视化设计器在两方面提供给第 3 方定制：
1. 支持 “资源页” 定制，参见 [“组织资源页”](#5.3.1.) 与 [“设计样板文件”](#5.3.2.) 两节内容。
2. 允许第 3 方扩展编辑器弹窗，让特定节点在选中后能用定制的弹窗修改属性。

原生 React 节点的界面特性，主体由传入 props 属性决定，少量由动态 state 属性决定。Shadow Widget 在此基础上，引入双源属性概念，让 “决定界面表现的 state 属性” 纳入到 duals 双源属性集合中，然后可视设计器为各构件的初始 “传入属性” 及动态可读写的 “双源属性” 提供属性编辑器，成为通用、可视的，在线编辑界面元素的解决方案。

Shadow Widget 规范定义读写构件属性的规格，把属性编辑器的定制能力开放，让通用的可视化编辑，演进为可广泛定制的界面设计器。

当众多厂商提供大量辅助界面设计器时，我们的插件系统要管理它们。插件被管理的基本单位是 “工具集”，也就是定义某个构件样板后，附加定义它浮动工具条上提供哪些按钮。每个工具集都由唯一 ID 标识，然后在该厂商所公开工程的根目录下 `TOOL.json` 文件中，定义各个工具集详细配置。

工具集的唯一 ID 采用路径形式表达，比如：

```
   rewgt/shadow-book/summary
   rewgt/shadow-book/content
   rewgt/$$ui-tool/unit-test/case_tree
```

全路径名用来唯一定位工具集，其首段是厂商名，上面 3 项的厂商均为 rewgt。为保证工具集唯一被定位，Shadow Widget 要求所用的厂商名唯一（要求只用 PINP 社区的注册名）。厂商名之后是工程名，如上面 `"shadow-book"` 与 `$$ui-tool/unit-test`，工程名可带 [分类目录](#3.2.1.!cate)，工程名之后是工具集名称，如上面 `"summary", "content", "case_tree"`。厂商名与工程名用来推导 `TOOL.json` 位置，如上两工程对应 URL：

```
    /app/rewgt/shadow-book/web/TOOL.json
    /app/rewgt/$$ui-tool/unit-test/web/TOOL.json
```

工具集 ID 名至少有三段，要求能从中找出厂商名、工程名、工具集名，找不出这三者就不是合法的工具集 ID。

通常我们将第 3 方共享的工程克隆到本地，与 shadow-server 工程（它为 Shadow Widget 提供本地 WebService 服务）同处一级，之后该第 3 方工程提供的可视编辑器就能正常供使用了。

用户在资源页拖入样板文件来创建一个构件时，工具集 ID 在样板文件的 `_widget.name` 记录，如果 `_widget.name` 名称不是合法的工具集 ID（比方只有一段，没定义多段），表示当前创建的构件不用定制的工具集，它的浮动工具条未经定制，只用缺省的工具集，实际由 WTC 内置定义来决定工具条如何显示，详见 [下一节](#5.3.4.)。

工具集 ID 将保存到 html 标签（在 `data-group.optid` 属性记录），下次打开编辑时，可视设计界面根据此 ID，从相应的 `TOOL.json` 文件找回工具集定义。

#### `TOOL.json` 内容格式

`TOOL.json` 文件用 JSON 格式，记录它所在工程的所有工具集定义，比如：

```
{
  "summary": {
    "name": "rewgt/shadow-book/summary",
    "opt": "mono/none",
    "baseUrl": "/app/rewgt/shadow-widget/output",
    "tools": []
  },
  
  "content": {
    "name": "rewgt/shadow-book/content",
    "opt": "mono/none",
    "baseUrl": "/app/rewgt/shadow-widget/output",
    "tools": []
  }
}
```

各个工具集要求定义 `"name, opt, baseUrl, tools"` 等项。其中 `name` 是工具集唯一 ID，`opt` 指示当前选中构件的下级成员是否可编辑，有如下 3 种选择：
1. `"mono/all"`，所有子级成员均可编辑，包括：增、删、改
2. `"mono/some"`，允许可视编辑器修改子成员，但不能删除
3. `"mono/none"`，可视编辑器不能对子成员增、删、改

`tools` 要求用数组 `[toolConfig, ...]` 定义各项操作，`baseUrl` 给出本工具集 URL 基址，`toolConfig.url` 若用相对地址，则参考这个 `baseUrl` 基址。

#### <a name="tool_config"></a>定义浮动按钮

上述 `tools` 的数组 `[toolConfig, ...]` 中，`toolConfig` 用来定义浮动工具条中的一个按钮，格式如下：

```
  {
    name: sName,
    icon: sIconFile,
    title: sTitle,
    url: sUrl,
    halfScreen: true_or_false,
    noMove: true_or_false,
    clickable: true_or_false,
    left: fLeft,
    top: fTop,
    width: fWidth,
    height: fHeight,
  }
```

其中，`name, icon, title` 用来设置浮动按钮的，`name` 指定操作名，如 `"editFont"`，`"addItem"` 等用来说明按钮的功能，一个特殊值 `"default"`，表示它是缺省操作，专供在设计器中双击选中构件时弹出编辑框。`icon` 指定浮动按钮的图标，要求是 "16 * 16" 像素的图片，图片文件既可以是绝对路径，也可以是 `_widget.baseUrl` 为基准的相对路径。`title` 指示浮动按钮的 hint 提示信息。

`url` 指示编辑器弹窗的页面，可用绝对路径，也可用相对路径。`halfScreen` 指示弹窗区域（含背景蒙板）是否只用左侧，空出右侧资源页区（以便从资源列表拖入文件），缺省值为 false，表示占用全屏。`noMove` 指示弹窗是否不可移动，缺省为 false，`clickable` 指示该操作是否用浮动按钮表达，取值为 true 表示用按钮，否则不显示按钮（如果是 default 缺省操作，鼠标双击已选中的构件也能召唤此操作）。

`left` 与 `top` 指定弹窗的左上角位置，既可以是像素值（值大于 1）也可以是百分比（取值0~0.9999），如果 `left` 或 `top` 缺省未定义，表示自动居中。`width` 与 `height` 指定弹窗的宽高，既可以是像素值（值大于 1）也可以是百分比（取值0~0.9999），如果未指定，宽与高自动取 `100%`。

#### 编辑器弹窗与主设计界面的通信机制

编辑器弹窗是一个独立的 Web 页，主设计界面通过 iframe 标签将弹窗 Web 页展示出来，两者之间的通信通过窗口 message 实现。

如下代码用于编辑器弹窗接收消息（无关代码已注释掉）：

```
  window.addEventListener('message', function(msg) {
    try {
      if (typeof msg == 'object' && msg.data) {
        msg = msg.data;
        msg = JSON.parse(msg.slice(14)); // remove prefix '[PROJECT_NAME]'
      }
      else msg = null;
    }
    catch(e) {
      msg = null;
      console.log(e);
    }
    
    if (typeof msg == 'object') {  // msg is: {method:'init', param:[...]}
      if (msg.method == 'init') {
        // process 'init' command, ...
      }
      else if (msg.method == 'close') {
        // process 'close' command, ...
      }
    }
  }, false);
```

传递的消息类似于函数调用，比如收到一个命令，`msg.method` 指出命令字（相当于给出函数名），`msg.param` 则用数组给出参数列表。

如果编辑器弹窗要向设计器主界面发送消息，采用如下代码：

```
  var msg = {method:'onDialogLoad',param:[]};
  var sCmd = '[PROJECT_NAME]' + JSON.stringify(msg);
  window.parent.window.postMessage(sCmd,'*');
```

同样，用 `msg.method` 指定命令字，用 `msg.param` 指定各个参数。设计器主界面的 message 消息接收与发送，与上面实现类似，原理一样，是对等的。

&nbsp;
