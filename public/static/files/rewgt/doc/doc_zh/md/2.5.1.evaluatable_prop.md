2.5.1 可计算属性
----------------

&nbsp;

可计算属性用 `'$'` 前缀来标识，其值是一个可解释执行的 javascript 表达式字串。

#### 一个简单例子

如下定义界面（请参考 demo26）：

```
  <div :t=Panel key='top' height='{null}'>
    <div :t=P key='hello' width='{0.9999}' $for='' dual-data='{{"name":"Wayne","lastName":"Chan"}}'>
      <span :t=Input key='name' $value='duals.data.name + " " + duals.data.lastName'></span>
    </div>
  </div>
```

`$value` 是可计算属性，其值是可计算的表达式。我们在 `hello` 节点定义 `duals.data`，然后在它的子节点的 `$value` 可计算表达式中就能引用 `duals.data` 变量了。

如上 `'$for'` 也用于定义一个可计算表达式，但它取空值有特殊含义：开启一个调用空间（call space）。从表达式所在位置向上级各节点遍历，只有 callspace 能找到时，可计算表达式才可以被解释执行。后文还会介绍 `'$for'` 取值为 `"item in expr"`，表示循环构造子节点，请您先记住，`$for=''` 是启用调用空间，这是让可计算表达式生效的**一种固定用法**。

#### 可计算属性能自动更新

上面程序运行中，如果改变 hello 节点的 `duals.data` 取值，`$value` 表达式将自动重新计算。比如在浏览器的控制台，输入如下脚本：

```
  W.body.top.hello.component.duals.data = {name:'Hillary', lastName:'Clinton'}
```

运行这行脚本后，Input 构件显示的文本自动变为：`"Hillary Clinton"`。因为 Shadow Widget 在编译可计算表达式时，识别哪些 duals 源数据被引用了，然后自动 listen 数据源，当源头数据变化时，将触发本表达式再作计算。

可计算表达式除了可引用源节点的 `duals.attr`，还可引用 `props.attr` 与 `state.attr`，不过，**只有对双源属性 `duals.attr` 的引用，才具备自动触发表达式重新计算的能力。**

#### 属性引用的路径

在可计算表达式中，`duals.attr`、`props.attr` 与 `state.attr` 可直接使用，均从最近的调用空间（callspace）所在的 R 节点读取（如上面举例的 `duals.data.lastName`）。因为调用空间可以有多层，每层调用都挂靠某个 R 节点，最近的调用空间是指从当前节点出发，向它的父级节点搜索，直到找到挂靠的调用空间。

由于这种向上搜索的定位方式，`duals.attr`、`props.attr`、`state.attr` 也可书写为 `duals(0).attr`、`props(0).attr`、`state(0).attr`，而再往上层取相关属性，可写成：

```
    duals(-1).attr    props(-1).attr    state(-1).attr
```

往上再查找一层：

```
    duals(-2).attr    props(-2).attr    state(-2).attr
```

以此类推，再往上用 `-3`、`-4` 等常数标识，注意：**要用常量**，而非变量来标记，因为自动更新的 listen 机制在表达式编译时刻就生成了，若用变量无从侦听。同理，使用 `duals(sPath)` 时 sPath 也要求用字串常量。 

这种栈式 “节点属性” 的引用机制，让跨层数据引用变方便了，产品开发更容易分层，在不同层级，使用不同功能、不同粒度的数据。

此外，可计算表达式还支持用相对路径（sPath）指示目标节点：

```
    duals(sPath).attr    props(sPath).attr    state(sPath).attr
```

相对路径的参考基点是最近调用空间（即：当前调用空间）所在的 R 节点。如上例，若将 `$value` 改成如下：

```
    $value='duals("//").keyid + ", " + duals("name").keyid'
```

表达式的计算结果将是 `"top, name"`。

#### 可计算属性允许被侦听

可计算属性 `$attr` 自动注册成双源属性 `duals.attr`，如上面例子使用了 `$value`，`duals.value` 即自动被注册，`state.value` 也自动可用，注意，这里属性名是去掉 `'$'` 前缀的。
 
可计算属性与常规双源属性一样，可以被侦听，比如（参见 demo26）：

```
  main['.body.top.hello.name'] = {
    componentDidMount: function() {
      this._componentDidMount(this);
      
      this.listen('value',function(value,oldValue) {
        console.log('value changed:',value);
      });
    },
  };
```

#### 三个特殊的可计算属性

1. `$html` 用来动态更新 `html.` 属性的值，比如：   
`    <span :t=Span key='txt' $html='"Hello, " + duals.data.name'></span>`

2. `$data` 相比于常规的可计算属性，差别仅在于：在一次更新中，它先于本节点其它可计算属性被计算。所以，我们常用 `$data` 集中表达入口数据，然后引用该数据（通常引用它的局部数据），形成若干延伸的可计算属性。`$data` 比其它表达式更早计算，这便于让延伸属性更 **“及时”** 的获得同步。

3. `$trigger` 表达式的计算结果要求是 array 数组，array 中各成员须是 `[sPath,modifier]`，`sPath` 用于找到目标节点的 `duals.data`（其值为空表示自身节点），结合 `modifier` 该表达式将依次对各数组成员作如下运算：   
&nbsp;&nbsp;&nbsp; `duals.data = ex.update(duals.data,modifier);`   
`$trigger` 表达式与选项构件的 `trigger` 属性都用于数据驱动，两者的规格接近，参见 [选项构件的数据驱动](#2.3.5.) 。   
如果 `$trigger` 只用于修改自身节点的 `duals.data`，可以简写，比如 `$trigger='{$merge:{disabled:""}}'`，这等效于 `$trigger='[["",{$merge:{disabled:""}}]]'`。

&nbsp;
